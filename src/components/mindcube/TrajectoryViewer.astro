---
// TrajectoryViewer.astro - Interactive component for viewing agent trajectories
---
<section id="data" class="content-section alt-background">
  <div class="section-container">
    <h2 class="section-title">MindCube Trajectory Examples</h2>
    <p class="section-description">Explore agent trajectories across different tasks. View state transitions, LLM-generated actions, and the decision-making process.</p>
    
    <div class="trajectory-viewer">
      <!-- Task Selection -->
      <div class="task-selector">
        <label for="model-select">Model:</label>
        <select id="model-select" class="model-dropdown">
          <option value="qwen2.5-0.5b">Qwen2.5-0.5B-Instruct</option>
        </select>
        
        <label for="task-select">Task:</label>
        <select id="task-select" class="task-dropdown">
          <!-- Task options will be dynamically populated by JavaScript -->
        </select>
        
        <label for="trajectory-select">Trajectory:</label>
        <select id="trajectory-select" class="trajectory-dropdown">
          <!-- Trajectory options will be dynamically populated by JavaScript -->
        </select>
      </div>
      
      <!-- Trajectory Timeline -->
      <div class="timeline-container">
        <div class="timeline">
          <div class="timeline-steps" id="timeline-steps">
            <!-- Timeline steps will be generated by JavaScript -->
            <div class="loading-indicator">
              <div class="spinner"></div>
              <p>Loading trajectory data...</p>
            </div>
          </div>
        </div>
        <div class="timeline-controls">
          <button id="prev-step" class="step-button" aria-label="Previous step">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
          </button>
          <span id="step-indicator" class="step-indicator">Step <span id="current-step">1</span> of <span id="total-steps">5</span></span>
          <button id="play-pause" class="play-button" aria-label="Play trajectory">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="play-icon">
              <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="pause-icon" style="display: none;">
              <rect x="6" y="4" width="4" height="16"></rect>
              <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
          </button>
        </div>
      </div>
      
      <!-- State and Action Display -->
      <div class="trajectory-display">
        <div class="state-container">
          <h3 class="display-subtitle">State</h3>
          <div class="state-content">
            <div class="state-image">
              <img id="state-image" src="/mindcube/placeholder-state.png" alt="Current state" />
            </div>
            <div class="state-description">
              <p id="state-text">State description will appear here. This represents the environment's current state at the selected step.</p>
            </div>
          </div>
        </div>
        
        <div class="action-container">
          <h3 class="display-subtitle">LLM Response</h3>
          <div class="action-content">
            <div class="llm-reasoning">
              <h4>Reasoning:</h4>
              <div id="reasoning-text" class="code-block">
                <p>Let me think about the current state...</p>
              </div>
            </div>
            <div class="llm-action">
              <h4>Action:</h4>
              <div id="action-text" class="code-block action-highlight">
                move_pawn('e2', 'e4')
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Trajectory Metrics -->
      <!--
      <div class="metrics-container">
        <h3 class="display-subtitle">Trajectory Metrics</h3>
        <div class="metrics-grid">
          <div class="metric-card">
            <span class="metric-label">Success</span>
            <span id="success-value" class="metric-value success">Yes</span>
          </div>
          <div class="metric-card">
            <span class="metric-label">Total Steps</span>
            <span id="total-steps-value" class="metric-value">12</span>
          </div>
          <div class="metric-card">
            <span class="metric-label">Valid Action Rate</span>
            <span id="valid-action-rate" class="metric-value">85%</span>
          </div>
          <div class="metric-card">
            <span class="metric-label">Effective Action Rate</span>
            <span id="effective-action-rate" class="metric-value">72%</span>
          </div>
        </div>
      </div>
      -->
    </div>
  </div>
</section>

<section id="demo" class="content-section alt-background">
  <div class="section-container">
    <h2 class="section-title">MINDCUBE Interactive Demo</h2>
    <p class="section-description">Explore how models generate cognitive maps and perform spatial reasoning on custom inputs. (Demo coming soon!)</p>
    <div class="diagram-placeholder">
              <img src="/mindcube/figures/mindcube-taxonomy.png" alt="MINDCUBE taxonomy figure" />
      <p style="text-align: center; color: #888;">MINDCUBE taxonomy: camera movement patterns and question types.</p>
    </div>
    <!-- Optionally, keep or adapt the interactive viewer if you have spatial reasoning data to show. -->
  </div>
</section>

<style>
  /* Add this at the end of the file, before the script tag */
  .ragen-logo {
    position: absolute;
    top: 20px;
    right: 20px;
    font-size: 24px;
    font-weight: bold;
    color: #333;
    font-family: 'Arial', sans-serif;
  }

  .section-container {
    position: relative;
    /* ... existing styles ... */
  }
</style>

<script>
  // This script will be client-side JavaScript for the TrajectoryViewer functionality
  document.addEventListener('DOMContentLoaded', () => {
    // Type definitions for trajectory data
    interface State {
      image?: string;
      description: string;
    }
    
    interface Step {
      state: State;
      reasoning?: string;
      action?: string;
    }
    
    interface Trajectory {
      name: string;
      description: string;
      totalSteps: number;
      success: boolean;
      validActionRate: string;
      effectiveActionRate: string;
      steps: Step[];
    }
    
    interface TaskData {
      taskName: string;
      taskDescription: string;
      trajectories: Record<string, Trajectory>;
    }
    
    interface Task {
      id: string;
      name: string;
      description: string;
      dataFile: string;
      thumbnail: string;
    }
    
    interface TaskIndex {
      version: string;
      lastUpdated: string;
      tasks: Task[];
    }
    
    // Trajectory viewer functionality
    // Element references
    const modelSelect = document.getElementById('model-select') as HTMLSelectElement;
    const taskSelect = document.getElementById('task-select') as HTMLSelectElement;
    const trajectorySelect = document.getElementById('trajectory-select') as HTMLSelectElement;
    const timelineStepsContainer = document.getElementById('timeline-steps');
    const currentStepElement = document.getElementById('current-step');
    const totalStepsElement = document.getElementById('total-steps');
    const stateImageElement = document.getElementById('state-image') as HTMLImageElement;
    const stateTextElement = document.getElementById('state-text');
    const reasoningTextElement = document.getElementById('reasoning-text');
    const actionTextElement = document.getElementById('action-text');
    const successValueElement = document.getElementById('success-value');
    const totalStepsValueElement = document.getElementById('total-steps-value');
    const validActionRateElement = document.getElementById('valid-action-rate');
    const effectiveActionRateElement = document.getElementById('effective-action-rate');
    const prevStepButton = document.getElementById('prev-step') as HTMLButtonElement;
    const nextStepButton = document.getElementById('next-step') as HTMLButtonElement;
    const playPauseButton = document.getElementById('play-pause') as HTMLButtonElement;
    
    // State variables
    let currentModel = 'qwen2.5-0.5b';
    let availableTasks: Task[] = [];
    let taskData: Record<string, TaskData> = {};
    let currentTaskId = '';
    let currentTrajectoryId = '';
    let currentStepIndex = 0;
    let isPlaying = false;
    let playInterval: number | null = null;
    
    // Display error message
    function showErrorMessage(message: string) {
      if (timelineStepsContainer) {
        timelineStepsContainer.innerHTML = `<div class="error-message">${message}</div>`;
      }
    }
    
    // Show loading indicator
    function showLoading() {
      if (timelineStepsContainer) {
        timelineStepsContainer.innerHTML = `
          <div class="loading-indicator">
            <div class="spinner"></div>
            <p>Loading trajectory data...</p>
          </div>
        `;
      }
    }
    
    // Load the task index from the appropriate model folder
    async function loadTaskIndex() {
      try {
        showLoading();
        
        // Add timestamp or random number to prevent caching
        const timestamp = new Date().getTime();
        const indexUrl = `/mindcube/data/trajectories/${currentModel}/index.json?t=${timestamp}`;
        console.log("Loading task index from:", indexUrl);
        
        const response = await fetch(indexUrl, { 
          cache: 'no-store' // Force not to use cache
        });
        if (!response.ok) {
          throw new Error(`Failed to load task index: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json() as TaskIndex;
        console.log("Available tasks:", data.tasks);
        availableTasks = data.tasks;
        
        // Populate task select dropdown
        if (taskSelect) {
          taskSelect.innerHTML = '';
          availableTasks.forEach(task => {
            const option = document.createElement('option');
            option.value = task.id;
            option.textContent = task.name;
            // Set Sokoban as default selected
            if (task.id === 'sokoban') {
              option.selected = true;
            }
            taskSelect.appendChild(option);
          });
          
          // Load Sokoban by default if available, otherwise load first task
          const sokobanTask = availableTasks.find(task => task.id === 'sokoban');
          if (sokobanTask) {
            await loadTaskData('sokoban');
          } else if (availableTasks.length > 0) {
            await loadTaskData(availableTasks[0].id);
          } else {
            showErrorMessage("No tasks available for the selected model.");
          }
        }
      } catch (error) {
        console.error('Error loading task index:', error);
        showErrorMessage(`Failed to load tasks: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }
    
    // Load task data with updated path structure
    async function loadTaskData(taskId: string) {
      try {
        showLoading();
        console.log("Loading task data for ID:", taskId);
        
        // Find the task info
        const taskInfo = availableTasks.find(task => task.id === taskId);
        if (!taskInfo) {
          throw new Error(`Task with ID ${taskId} not found`);
        }
        
        // Ensure using the correct model path
        let dataPath = taskInfo.dataFile;
        // Ensure the path includes model name
        if (!dataPath.includes(`/mindcube/data/trajectories/${currentModel}/`)) {
          // Completely replace dataPath with the correct path
          const fileName = dataPath.split('/').pop(); // Get the file name
          dataPath = `/mindcube/data/trajectories/${currentModel}/${fileName}`;
        }
        
        // Add timestamp to avoid caching
        const timestamp = new Date().getTime();
        dataPath = `${dataPath}?t=${timestamp}`;
        
        console.log("Loading data from path:", dataPath);
        const response = await fetch(dataPath, {
          cache: 'no-store' // Force not to use cache
        });
        if (!response.ok) {
          throw new Error(`Failed to load task data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json() as TaskData;
        console.log("Task data loaded:", data.taskName, "with", Object.keys(data.trajectories).length, "trajectories");
        taskData[taskId] = data;
        currentTaskId = taskId;
        
        // Populate trajectory select dropdown
        if (trajectorySelect) {
          trajectorySelect.innerHTML = '';
          
          Object.entries(data.trajectories).forEach(([id, trajectory]) => {
            const option = document.createElement('option');
            option.value = id;
            option.textContent = trajectory.name || id;
            trajectorySelect.appendChild(option);
          });
          
          // Load the first trajectory by default
          if (trajectorySelect.options.length > 0) {
            currentTrajectoryId = trajectorySelect.options[0].value;
            initializeTimeline();
          } else {
            showErrorMessage(`No trajectories available for task: ${data.taskName}`);
          }
        }
      } catch (error) {
        console.error(`Error loading task data for ${taskId}:`, error);
        showErrorMessage(`Failed to load data for ${taskId}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }
    
    // Initialize the timeline with updated metrics
    function initializeTimeline() {
      if (!timelineStepsContainer || !currentTaskId || !currentTrajectoryId) return;
      
      const currentTask = taskData[currentTaskId];
      if (!currentTask) {
        console.error("Task data not found for ID:", currentTaskId);
        showErrorMessage(`Task data not found for: ${currentTaskId}`);
        return;
      }
      
      const trajectory = currentTask.trajectories[currentTrajectoryId];
      if (!trajectory) {
        console.error("Trajectory not found for ID:", currentTrajectoryId);
        showErrorMessage(`Trajectory not found for: ${currentTrajectoryId}`);
        return;
      }
      
      console.log("Initializing timeline for trajectory:", trajectory.name, "with", trajectory.steps.length, "steps");
      
      const totalSteps = trajectory.steps.length;
      if (totalSteps === 0) {
        console.error("Trajectory has no steps");
        showErrorMessage("Selected trajectory has no steps to display");
        return;
      }
      
      // Clear existing timeline steps
      timelineStepsContainer.innerHTML = '';
      
      // Add timeline progress bar
      const progressBar = document.createElement('div');
      progressBar.className = 'timeline-progress';
      
      // If there's only one step, progress bar displays 100%
      if (totalSteps === 1) {
        progressBar.style.width = '100%';
      } else {
        progressBar.style.width = '0%';
      }
      
      timelineStepsContainer.appendChild(progressBar);
      
      // Add step markers
      for (let i = 0; i < totalSteps; i++) {
        const step = document.createElement('div');
        step.className = 'timeline-step';
        
        // If there's only one step, place the node on the right (100% position)
        if (totalSteps === 1) {
          step.style.left = '100%';
        } else {
          step.style.left = `${(i / (totalSteps - 1 || 1)) * 100}%`;
        }
        
        step.dataset.index = i.toString();
        
        step.addEventListener('click', () => {
          navigateToStep(i);
        });
        
        timelineStepsContainer.appendChild(step);
      }
      
      // Update step counter
      if (currentStepElement) currentStepElement.textContent = '1';
      if (totalStepsElement) totalStepsElement.textContent = totalSteps.toString();
      
      // Update metrics
      updateMetricsDisplay(trajectory);
      
      // Navigate to first step
      navigateToStep(0);
    }
    
    // Navigate to a specific step
    function navigateToStep(stepIndex: number) {
      if (!currentTaskId || !currentTrajectoryId) return;
      
      const currentTask = taskData[currentTaskId];
      if (!currentTask) return;
      
      const trajectory = currentTask.trajectories[currentTrajectoryId];
      if (!trajectory) return;
      
      const totalSteps = trajectory.steps.length;
      
      if (stepIndex < 0 || stepIndex >= totalSteps) {
        return;
      }
      
      currentStepIndex = stepIndex;
      const step = trajectory.steps[stepIndex];
      
      // Update step counter
      if (currentStepElement) currentStepElement.textContent = (stepIndex + 1).toString();
      
      // Update timeline UI
      if (timelineStepsContainer) {
        const steps = timelineStepsContainer.querySelectorAll('.timeline-step');
        const progressBar = timelineStepsContainer.querySelector('.timeline-progress') as HTMLElement;
        
        steps.forEach((stepEl, index) => {
          if (index < stepIndex) {
            stepEl.className = 'timeline-step completed';
          } else if (index === stepIndex) {
            stepEl.className = 'timeline-step active';
          } else {
            stepEl.className = 'timeline-step';
          }
        });
        
        // Update progress bar
        if (progressBar) {
          // If there's only one step, keep progress bar at 100%
          if (totalSteps === 1) {
            progressBar.style.width = '100%';
          } else {
            const progressPercentage = (stepIndex / (totalSteps - 1)) * 100;
            progressBar.style.width = `${progressPercentage}%`;
          }
        }
      }
      
      // Update state and action display
      if (stateImageElement) {
        const imagePath = step.state.image || '';
        
        // If image path exists, display the image area, otherwise hide it
        const imageContainer = stateImageElement.closest('.state-image');
        if (imageContainer) {
          if (imagePath) {
            (imageContainer as HTMLElement).style.display = 'block';
            console.log("Loading image from:", imagePath);
            
            // Method to prevent cyclic loading errors
            if (imagePath !== '/mindcube/placeholder-state.png') {
              // Create new Image object to preload and check if the image exists
              const img = new Image();
              img.onload = function() {
                stateImageElement.src = imagePath;
              };
              img.onerror = function() {
                console.error("Failed to load image:", imagePath);
                stateImageElement.src = '/mindcube/placeholder-state.png';
              };
              img.src = imagePath;
            } else {
              stateImageElement.src = '/mindcube/placeholder-state.png';
            }
          } else {
            // If no image path, hide the image container
            (imageContainer as HTMLElement).style.display = 'none';
          }
        }
      }
      
      // Process text description, support code blocks
      if (stateTextElement) {
        const description = step.state.description || '';
        if (description) {
          // Check if it contains code block markers ```
          if (description.includes('```')) {
            // Use regular expression to process code blocks, and keep possible language markers
            const formattedDescription = description.replace(/```([\w]*)?(\r\n|\n)([\s\S]*?)```/g, (match, lang, newline, code) => {
              // Extract code content and language identifier
              const language = lang ? lang.trim() : '';
              const codeContent = code.trim();
              const languageClass = language ? ` language-${language}` : '';
              
              return `<div class="code-block${languageClass}"><pre>${codeContent}</pre>${language ? `<div class="code-language">${language}</div>` : ''}</div>`;
            });
            
            // Process plain code blocks without language identifiers
            const finalDescription = formattedDescription.replace(/```([\s\S]*?)```/g, (match, code) => {
              return `<div class="code-block"><pre>${code.trim()}</pre></div>`;
            });
            
            stateTextElement.innerHTML = finalDescription;
          } else {
            // No code blocks, directly set text
            stateTextElement.innerHTML = description.replace(/\n/g, '<br>');
          }
          stateTextElement.closest('.state-description')?.classList.remove('hidden');
        } else {
          stateTextElement.textContent = 'No description available.';
          stateTextElement.closest('.state-description')?.classList.add('hidden');
        }
      }
      
      // Process reasoning text
      if (reasoningTextElement) {
        const reasoning = step.reasoning || '';
        const reasoningContainer = reasoningTextElement.closest('.llm-reasoning');
        
        if (reasoning) {
          reasoningTextElement.innerHTML = `<p>${reasoning}</p>`;
          if (reasoningContainer) (reasoningContainer as HTMLElement).style.display = 'block';
        } else {
          reasoningTextElement.innerHTML = '<p>No reasoning available.</p>';
          if (reasoningContainer) (reasoningContainer as HTMLElement).style.display = 'none';
        }
      }
      
      // Process action text
      if (actionTextElement) {
        const action = step.action || '';
        const actionContainer = actionTextElement.closest('.llm-action');
        
        if (action) {
          actionTextElement.textContent = action;
          if (actionContainer) (actionContainer as HTMLElement).style.display = 'block';
        } else {
          actionTextElement.textContent = 'No action available.';
          if (actionContainer) (actionContainer as HTMLElement).style.display = 'none';
        }
      }
      
      // Update button states
      if (prevStepButton) prevStepButton.disabled = stepIndex === 0;
      if (nextStepButton) nextStepButton.disabled = stepIndex === totalSteps - 1;
    }
    
    // Play trajectory automatically
    function playTrajectory() {
      if (!currentTaskId || !currentTrajectoryId) return;
      
      const currentTask = taskData[currentTaskId];
      if (!currentTask) return;
      
      const trajectory = currentTask.trajectories[currentTrajectoryId];
      if (!trajectory) return;
      
      if (isPlaying) {
        if (playInterval !== null) {
          clearInterval(playInterval);
          playInterval = null;
        }
        
        const playIcon = playPauseButton?.querySelector('.play-icon') as HTMLElement;
        const pauseIcon = playPauseButton?.querySelector('.pause-icon') as HTMLElement;
        
        if (playIcon) playIcon.style.display = 'block';
        if (pauseIcon) pauseIcon.style.display = 'none';
        
        isPlaying = false;
      } else {
        playInterval = window.setInterval(() => {
          if (currentStepIndex < trajectory.steps.length - 1) {
            navigateToStep(currentStepIndex + 1);
          } else {
            if (playInterval !== null) {
              clearInterval(playInterval);
              playInterval = null;
            }
            
            const playIcon = playPauseButton?.querySelector('.play-icon') as HTMLElement;
            const pauseIcon = playPauseButton?.querySelector('.pause-icon') as HTMLElement;
            
            if (playIcon) playIcon.style.display = 'block';
            if (pauseIcon) pauseIcon.style.display = 'none';
            
            isPlaying = false;
          }
        }, 2000); // Advance every 2 seconds
        
        const playIcon = playPauseButton?.querySelector('.play-icon') as HTMLElement;
        const pauseIcon = playPauseButton?.querySelector('.pause-icon') as HTMLElement;
        
        if (playIcon) playIcon.style.display = 'none';
        if (pauseIcon) pauseIcon.style.display = 'block';
        
        isPlaying = true;
      }
    }
    
    // Update metrics display with new metrics
    function updateMetricsDisplay(trajectory: Trajectory) {
      console.log("Updating metrics display:", {
        totalSteps: trajectory.totalSteps,
        success: trajectory.success,
        validActionRate: trajectory.validActionRate,
        effectiveActionRate: trajectory.effectiveActionRate
      });
      
      if (totalStepsValueElement) totalStepsValueElement.textContent = trajectory.totalSteps.toString();
      
      if (successValueElement) {
        successValueElement.textContent = trajectory.success ? 'Yes' : 'No';
        successValueElement.className = trajectory.success ? 'metric-value success' : 'metric-value failure';
      }
      
      if (validActionRateElement) {
        validActionRateElement.textContent = trajectory.validActionRate || 'N/A';
      }
      
      if (effectiveActionRateElement) {
        effectiveActionRateElement.textContent = trajectory.effectiveActionRate || 'N/A';
      }
    }
    
    // Initialize model selection and the rest of controls
    function initializeControls() {
      if (prevStepButton) {
        prevStepButton.addEventListener('click', () => {
          if (currentStepIndex > 0) {
            navigateToStep(currentStepIndex - 1);
          }
        });
      }
      
      if (nextStepButton) {
        nextStepButton.addEventListener('click', () => {
          if (!currentTaskId || !currentTrajectoryId) return;
          
          const currentTask = taskData[currentTaskId];
          if (!currentTask) return;
          
          const trajectory = currentTask.trajectories[currentTrajectoryId];
          if (!trajectory) return;
          
          if (currentStepIndex < trajectory.steps.length - 1) {
            navigateToStep(currentStepIndex + 1);
          }
        });
      }
      
      if (playPauseButton) {
        playPauseButton.addEventListener('click', playTrajectory);
      }
      
      if (modelSelect) {
        modelSelect.addEventListener('change', async (e) => {
          const target = e.target as HTMLSelectElement;
          currentModel = target.value;
          await loadTaskIndex(); // Reload tasks for the selected model
        });
      }
      
      if (taskSelect) {
        taskSelect.addEventListener('change', async (e) => {
          const target = e.target as HTMLSelectElement;
          await loadTaskData(target.value);
        });
      }
      
      if (trajectorySelect) {
        trajectorySelect.addEventListener('change', (e) => {
          const target = e.target as HTMLSelectElement;
          currentTrajectoryId = target.value;
          initializeTimeline();
        });
      }
    }
    
    // Initialize the trajectory viewer
    async function initializeTrajectoryViewer() {
      await loadTaskIndex();
      initializeControls();
    }
    
    // Initialize if the DOM elements exist
    if (taskSelect && trajectorySelect && timelineStepsContainer) {
      initializeTrajectoryViewer().catch(error => {
        console.error('Failed to initialize trajectory viewer:', error);
      });
    }
  });
</script> 